#include<Windows.h>
#include<iostream>
//https://youtu.be/Uob6oSJYhVc?si=Rl4bIyqLB5PXkLP9
		LRESULT CALLBACK WndProc(HWND hwnd /*дескриптор окна*/, UINT iMsg /*идентификатор сообщения*/, WPARAM wParam, LPARAM lParam)   // оконная процедура нужна, чтобы обрабатывать сообщение посылаемое при закрытии окна напрямую минуя очередь сообщений
		{
			std::cout << "WndProc iMsg: " << "Ox" << iMsg << std::endl; // сама по себе оконная процедура ничего не обрабатывает
			// для того чтобы обрабатывать те многочисленные сообщения, которые происходят в нашей программе, мы по прежнему будем использовать оконную процедуру по умаолчанию
			// теперь для того, чтобы обработать сообщение WM_DESTROY  (0x0002 посылаемое при закрытии окна)
			if (iMsg == WM_DESTROY)
			{
				// реализуем логику завершения работы приложения, наша задача прервать цикл whil (1)  (см.снизу)
				// для этого в очередь сообщений нужно поместить некоторое сообщение со специальным кодом, которое будет сообщать, что приложение нужно завершить
				//  в качестве такого сообщения используется сообщение WM_QUIT  (0x0012) 
				// для того, чтобы поместить сообщение в очередь, воспользуемя функцией PostQuitMessage(0)
				PostQuitMessage(0); // 0 означает планавое завершение приложения
				return 0;
			}
			return DefWindowProc(hwnd, iMsg, wParam, lParam); // т.е. наша оконная процедура будет какбы надстройкой над оконной процедурой по умолчанию
			// таким образом при закрытии окна мы отравляем сообщение в приложение сообщение с кодом 0x0012
		}
//INT WINAPI WinMain(
//	HINSTANCE hInstance, //  дескриптор экземпляра текущего приложения, HINSTANCE - Handle Instance
//	HINSTANCE hPrevInst, // hPrevInstance - дескриптор предыдущего экземпляра приложения, - Handle Previous Instance
//	LPSTR lpszCmdLine, // Long Pointer to String ( разрядность которого соответствует разрядности нашей прграммы т.е. 64 бит  .... lpszCmdLine  прдоставляет доступ ко командной строке
//	//  -  long pointer to string zero Command Line  -  указатель на строку (string zero - означает строка в конце который байт с нулевым значением) 
//	// Command Line - означает что данная строка содержит переменные переданные через командную строку
//	INT CmdShow  //  используется для последующей передачи в функцию BOOL ShowWindow(...), определяет режим отображения окна (свёрнутое, развернутое и т.д.)
//)
	int main(int argc, char *argv[])  //вместо WinMain можно использовать и обычную функцию main(), но нам нужно как то получить дескриптор экземпляра текущего приложения hInstance
{
	HINSTANCE hInstance = GetModuleHandleA(0); // чтобы использовать main() вместо WinMain()  55:00
	int iShow = 10; // для ShowWindow означает, что режим отображения окна SW_SHOWDEFAULT т.е. мы можем режим указать через ярлык
	char wnd_class_name[] = "draw_window"; // следует обратить внимание, если добавляем строку в ковычках, то автоматически добавляется нулевой байт
	// прежде чем создать окно, необходимо создать класс окна
	WNDCLASSEX wnd_class; // структура класса окна имеет тип  WNDCLASSEX    (WNDCLASSEX - ANSI, WNDCLASEXA - ANSI, WNDCLASEXW  - Unicode)
	//std::cout << "hInstance: 0x%p\t\t" << hInstance << std::endl;			(CreateWindow - ANSI, CreateWindowA - ANSI, CreateWindowW - Unicode)
	// WNDCLASEX aлиас структуры tagWNDCLASSEXA   11:00   https://youtu.be/Uob6oSJYhVc?si=56xMhD5W5kwnhjS7&t=716
	// для работы с этой структурой сначала нужно все поля обнулить, затем задать значения полям, которые нам нужны, первым вариантом можно все поля перечислить и присвоить им 0, 
	// но лучше использовать более кратко функцию  memset
	memset(&wnd_class, 0, sizeof(wnd_class));  // устанавливает все поля структуры wnd_class  в 0
	// затем нужно заполнить поля, первое поле это cbSize - count bytes size - данный параметр содержит размер структуры в байтах, в это поле структуры помещаем размер структуры
	wnd_class.cbSize = sizeof(wnd_class); // здесь мы можем указть либо имя переменной, либо тип структуры : ... = sizeof(WNDCLASSEX);
	// следующее поле для нас важное это lpfnWndProc - long pointer to function Window Procedure ( длиный указатель на функцию, которая выполняет роль оконной процедуры
	// оконная процедура это функция которая обрабатывает различные события который происходят в намем окне) на данный момент у нас ещё нет никаких оконных процедур, но windows предоставляет
	// её по умолчанию  DefWindoProc - Default Window Procedure
	wnd_class.lpfnWndProc = WndProc ; // DefWindowProcA;  // Default Window Procedure
	wnd_class.hInstance = hInstance; // сюда загружаем дескриптор экземпляра текущего приложения взятый из первого аргумента функции WinMain
	// и ещё нужен один параметр  lpszClassName - long pointer to string zero class name  ( длинный указатель на строку оканчивающуюся нулем, которая содержит в себе имя класса)
	// здесь нам нужно придумать имя класса на основе которого мы будем делать конкретный экземпляр 
	// для хранения класса окна создадим массив char и  поместим туда строку в ковычках
	wnd_class.lpszClassName = wnd_class_name;
	wnd_class.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
	wnd_class.hCursor = LoadCursorA(NULL, IDC_ARROW); // чтобы курсор над областью окна имел вид стандартной стрелки
	wnd_class.hIcon = LoadIconA(NULL, IDI_APPLICATION);  // иконка в левом верхнем углу окна
	wnd_class.hIconSm = LoadIconA(NULL, IDI_APPLICATION); // иконка на панели задач

	// далее прежде чем использовать структуру окна, нам нужно зарегистрировать этот класс окна 
	if (!RegisterClassEx(&wnd_class)) // в качестве аргумента эта функция принимает адрес структуры класса окна
	{   // теперь, когда мы создали и зарегистрировали класс окна, мы можем создавать экземпляры окна на основе этого класса
		MessageBoxA(NULL, "Window Registation Failed!", "Error", MB_ICONEXCLAMATION | MB_OK);
		return 0;
	}	// для создания окна воспользуемся функцией CreateWindow() - принимает 11 параметров;
	char title[] = "window title";
		HWND hwnd = CreateWindowA(wnd_class_name, title, WS_OVERLAPPEDWINDOW, 200, 100, 600, 400,0,0,hInstance,0);    //HWND - Handler Window, hwnd - это дескриптор окна , третий параметр добавляет кнопки закрытия, сворачивания окна   200 - x, 100 - y, 600 - width, 400 - height
		if (hwnd == NULL)
		{
			MessageBoxA(NULL, "Window Creation Failed!", "Error", MB_ICONEXCLAMATION | MB_OK);
		}
		// Teперь когда окно создано можем с помощь функции  ShowWindow  вывести его на экран
		ShowWindow(hwnd, iShow); //SW_NORMAL); // окно мелькнуло на экране и сразу же исчезло, это происходит потому, что сразу после вызова функции прорграмма завершается добавим задержку
		UpdateWindow(hwnd);
		//Sleep(3000); // окно держится на экране три секунды и исчезает
	// нам нужно, чтобы окно закрывалось не по истечению какого-то фиксированного времени, а когда пользователь нажимает на кнопку закрытия окна
	// для того, чтобы пользоваетель мог взаимодействовать с окном, существует специальный механизм сообщений
	// заключается в следующем, когда пользоваетль например щёлкает мышью в определенной области окна, то говорят, что произошло событи щелчка мыши
		// когда  на клавиатуре -//- событие на клавиатуре и для того чтобы уведомлять программу о таких событиях сущесвует механизм сообщений, т.е. когда
		// пользователь осуществляет какое то действие в оконном приложении, то в программу отправляется соответствующее сообщение и таким образом оконное приложение
		// может реагировать и обрабатывать эти события. Сообщения представляют собой структуру с типом MSG 
		MSG msg; // в этой структуре нас будет интересовать параметр   UINT   message;  который хранит код сообщения -> https://autoit-script.ru/docs/appendix/winmsgcodes.htm?ysclid=llnii5x9v2629244218
		// для того, чтобы обрабатываеть последовательность сообщений, которое будет поступать в приложение, создаётся цикл:
		int status;
		while (1) // сообщения которые поступают в нашу программу формируют очередь сообщений и для того, чтобы извлечь очередное сообщение из этой очредеи
		{			// можно воспоьзоваться функцией:
			status = GetMessageA(&msg,0,0,0);  // возвращает 0 если возвращает сообщение о закрытии программы, 1 - другие, -1 если ошибка// здесь происходит извлечение сообщений из очереди сообщений, эта функция принимает четыре параметра, первый параметр это указатель на структуру, в эту структуру будут сохранены параметры сообщения
		  // для хранения параметров сообщения мы создали переменную msg и теперь адрес этой переменной мы указываем в качестве первого аргумента функции GetMessage()
		// второй аргумент дескриптор окна от которого мы хотим обрабатывать сообщения, мы указываем 0 значение, и это будет означать, что мы обрабатываем сообщения от всех окон
		// нашего приложения, следующие два параметра это минимальный и максимальный идентификаторы сообщений, которые мы будем обрабатывать, например мы можем указать, что
		// мы обрабатываем только те  сообщения, идентификаторы, которых находятся в диапазоне начиная от шестнадцатиричного значения 0x100 и заканчивая шестнадцатиричным значенимем 0x109
		// т.е. мы обрабатываем только те сообщени, которые возникли в результате нажати клавиш на клавиатуре, мы укажем 0 значения, и это означает, что мы будем обрабатывать все 
		// сообщения, которые отправляются нашему приложению, теперь для того чтобы посмотреть, какие сообщения отравляются нашему приложению выведем на экран поле message структуры MSG
			std::cout << msg.message << std::endl;
					// if (msg.message == WM_QUIT) // если в приложение поступает сообщение с кодом 0x0012 , завершаем
				if (status ==0)
					{
						break;
					}
				
			// На экране появилось окно, а в командной строке в бесконечном цикле происходит вывод сообщения с кодом f, для того чтобы прервать этот цикл нажмём ctrl + c в командной строке
			// приложение будет завершено а окно будет закрыто. 
			// Сообщение с кодом 0x000F  - это сообщение WM_PAINT  -  Window Message Paint , отличительной особенностью данного сообщения является то, что данное сообщение обязательно 
			// должно быть обработано. Если это сообщение не обрабатывается, что оно будет в безконечном цикле отсылаться нашему приложению. Для того, чтобы обработать сообщения нужно
			// воспользоваться функцией DispatchMessage - которая в качестве аргумента принимает адрес структуры сообщения
			DispatchMessageA(&msg); // эта функция в свою очередь вызывает функцию, которая была указана в lpfnWndProc структуры класса окна WNDCLASSEX, 
			// запустим программу, и в появившемся окне поводим мышью, в консоли мы будем видеть вывод сообщений с кодом 0x0200 WM_MOUSEMOVE , они уведомляют программу о том 
			// что над окном приложения перемещается курсор мыши, теперь когда мы отркыли окно, нам нужно его закрыть, но сейчас у этого окна нет никаких кнопок и мы никак не можем
			// с ним взаимодействовать, поэтому сейчас для того, чтобы закрыть окно, нужно перейти в командную строку и нажать ctrl + c , программа будет завершена и окно приложения будет закрыто
			// Для того чтобы у окна был базовый набор кнопок стандартного окна Windows, нам нужно это указать в стиле окна. Следует обратить внимание, что есть понятие стиль конкрентного 
			// экземпляра окна, который указывается в третьем аргументе функции CreateWindowA , а есть понятие стиль класса окна, который указывается в соответствующем поле структуры
			// класса окна WINDCLASSEX. Нас сейчас интересует стиль конкретного экземляра окна. Возможные значния параметра стиля можно найти в таблице стилей окна https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles
			// нас интересует это значение WS_OVERLAPPEDWINDOW -  Windows Style, укажем в качестве третьего аргумента функции CreateWindowA, и теперь можно закрыть программу с помощью
			// станадртной кнопки закрытия окна. Но не смотря на то, что окно закрылась приложение до сих про работает, в командной строке не можем набирать команды, потому что не завершено текущее приложение
			// для того, чтобы его завершить нужно нажать Ctrl + c, если нам нужно чтобы при закрытии окна завершало работу и само приложение, нам нужно обработать приложение 
			// WM_DESTROY с кодом 0x0002 именно это сообщение отправляется, когда пользователь нажимает кнопку закрытия окна, но если посмотреть на те собщения, 
			// которые были, мы не увидим с кодом 2, последнее сообщение имеет код a1  - это  0x00A1    WM_NCLBUTTONDOWN (Window Message Non Client Left Button Down - 
			// т.е. сообщение щелчка левой кнопки мыши в не клиенсткой области окна.
			//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
			// Дело в том, что сообщения могут отправляются двумя способами:
//			      @ -  Первый способ это когда сообщения отрправляются в очередь, потом оно извлекаются из этой очереди функцией 
//												 >>>>>>>   GetMessageA(&msg, 0,0,0),  <<<<<<<<
// 			   отправляются на обработку функцией   >>>>>>   DispatchMessage(...)  <<<<<<<   и в ходе работы этой функции сообщение будет обработано 
			// в той оконной процедуре              >>>>>>	 DefWindowProc       <<<<<<<<  которая была указана в соответствующем поле класса окна
			//										>>>>>>>  wnd_class.lpfnWndProc  <<<<<<<<         те сообщения, коды которых выводились в консоль( 0xa0, 0xa1) это сообщения, которые были извлечены из очереди сообщений с помощью функции GetMessage
//				  @ -  Второй способ отправки сообщений, это когда сообщение отправляется не в очередь сообщений, а напрямую в оконную процедуру  : wnd_class.lpfnWndProc = DefWindowProc ,т.е. какбы в обход этой очереди
			// сообщение WM_DESTROY, которое происходит при закрытии окна отправляется напрямую в оконную процедуру,  из-за этого сообщения нет в очереди сообщений и нет в выводе на консоли
			// и следовательно мы не можем обработать это сообщение в данном цикле. 

		}
//				Оконная процедура по умолчанию - DefWindowProc - не завершает работу приложения при закрытии окна (существуют разные приложения, одни закрываются вызовом процедуры по умолчанию, другие нет и продолжают работу в фаоновом режиме)
			// Если нам нужно, чтобы приложение закрывалось вместе с закрытием окна, то нужно самостоятельно прописать логику закрытия приложения при закрытии окна https://youtu.be/Uob6oSJYhVc?si=6XI34SyVtPOTssdh&t=2186
			// Так как DefWindowProc - процедура по умполчанию не завершает работу приложения, то нам нужна собственная процедура WndProc (см.вверху), которая будет это делать.
			// В этой процедуре прежде всего будут важны первые два аргумента



	return (int)msg.wParam;
}